//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using System.Collections.Generic;

namespace library
{
    public unsafe partial class lammps :IDisposable
    {
        IntPtr lmp;
        bool disposed = false;
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_open")]
            internal static extern void lammps_open_0(int _0, string[] _1, IntPtr _2, void** _3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_open_no_mpi")]
            internal static extern void lammps_open_no_mpi_0(int _0, string[] _1, void** _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_open_no_mpi")]
            internal static extern void lammps_open_no_mpi_1(int _0,  string[] _1, HandleRef _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_close")]
            internal static extern void lammps_close_0(HandleRef _0h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_close")]
            internal static extern void lammps_close_0(IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_file")]
            internal static extern void lammps_file_0(HandleRef _0h, string _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_file")]
            internal static extern void lammps_file_0(IntPtr _0, string _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_command")]
            internal static extern string lammps_command_0(HandleRef _0h, string _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_command")]
            internal static extern IntPtr lammps_command_1(HandleRef _0h, string _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_command")]
            internal static extern IntPtr lammps_command_0(IntPtr _0, string _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_free")]
            internal static extern void lammps_free_0(HandleRef _0h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_extract_global")]
            internal static extern IntPtr lammps_extract_global_0(HandleRef _0h, string _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_extract_atom")]
            internal static extern IntPtr lammps_extract_atom_0(HandleRef _0h, string _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_extract_atom")]
            internal static extern IntPtr lammps_extract_atom_0(IntPtr _0, string _1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_extract_compute")]
            internal static extern IntPtr lammps_extract_compute_0(HandleRef _0h, string _1, int _2, int _3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_extract_compute")]
            internal static extern IntPtr lammps_extract_compute_0(IntPtr _0, string _1, int _2, int _3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_extract_fix")]
            internal static extern IntPtr lammps_extract_fix_0(HandleRef _0h, string _1, int _2, int _3, int _4, int _5);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_extract_variable")]
            internal static extern IntPtr lammps_extract_variable_0(HandleRef _0h, string _1, string _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_get_natoms")]
            internal static extern int lammps_get_natoms_0(HandleRef _0h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_get_natoms")]
            internal static extern int lammps_get_natoms_0(IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_gather_atoms")]
            //internal static extern void lammps_gather_atoms_0(HandleRef _0h, string _1, int _2, int _3, int* _4);
            //internal static extern void lammps_gather_atoms_0(HandleRef _0h, string _1, int _2, int _3, void* _4);
            internal static extern void lammps_gather_atoms_0(HandleRef _0h, string _1, int _2, int _3,  IntPtr _4);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_gather_atoms")]
            //internal static extern void lammps_gather_atoms_0(HandleRef _0h, string _1, int _2, int _3, int* _4);
            //internal static extern void lammps_gather_atoms_0(HandleRef _0h, string _1, int _2, int _3, void* _4);
            internal static extern void lammps_gather_atoms_0(IntPtr _0, string _1, int _2, int _3,  IntPtr _4);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("liblammps_ubuntu.so", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="lammps_scatter_atoms")]
            internal static extern void lammps_scatter_atoms_0(HandleRef _0h, string _1, int _2, int _3, HandleRef _4);
        }
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);

        }
        protected virtual void Dispose(bool disposing)
        {
            if (disposed)
                return;
            if (disposing)
            {
                lammps_close(lmp);

            }
            disposed = true;
        }
//        public static void lammps_open(int _0, string[] _1, IntPtr _2, void** _3)
//        {
//            var arg1 = _1;
//            var arg3 = _3;
//            Internal.lammps_open_0(_0, arg1, _2, arg3);
//        }
        public static IntPtr lammps_open(int numargs, string[] arguments,IntPtr comm)
        {
            void* lamp;

            var lmpptr = &lamp;

            Internal.lammps_open_0(numargs,arguments,comm,lmpptr);

            return new IntPtr(lamp);
        }

//        public static HandleRef lammps_open_no_mpi(int _0, string _1)
//        {
//            var arg1 = _1;
//            void* lmp;
//            Internal.lammps_open_no_mpi_0(_0, arg1, &lmp);
//            HandleRef ptr2lammps = new HandleRef(lmp);
//            return ptr2lammps;
//        }
        public static void lammps_open_no_mpi(int _0, string[] _1, HandleRef _3)
        {
            var arg1 = _1;
            //var arg3 = _3;
//            IntPtr[] argv = new IntPtr[_1.Length];
//            for (int i = 0; i <= _1.Length; i++)
//            {
//                argv[i]=StringToByteArray(_1[i]);
//            }
//            int len = _1.Length;
//            char*[] argv = new char*[len];
//
//            for(int i = 0; i < len; ++i)
//            {
//                argv[i] = (char*)Marshal.StringToHGlobalAnsi(_1[i]).ToPointer();
//            }
//
            Internal.lammps_open_no_mpi_1(_0, arg1, _3);

           
        }
        public static void lammps_open_no_mpi(int _0, string[] _1, void** _2)
        {
            var arg1 = _1;
            var arg2 = _2;


            Internal.lammps_open_no_mpi_0(_0, arg1, arg2);
        }


        public static IntPtr lammps_open_no_mpi(int _0, string[] arguments)
        {
            void* lamp;

            var arg2 = &lamp;


            Internal.lammps_open_no_mpi_0(_0, arguments, arg2);
            return new IntPtr(lamp);
        }
       
//        public static void lammps_close(HandleRef _0h)
//        {
//            var arg0 = _0h;
//            Internal.lammps_close_0(arg0);
//        }

        public static void lammps_close(IntPtr _0)
        {
            var arg0 = _0;
            Internal.lammps_close_0(arg0);
        }

//        public static void lammps_file(HandleRef _0h, string _1)
//        {
//            var arg0 = _0h;
//            var arg1 = _1;
//            Internal.lammps_file_0(arg0, arg1);
//        }

        public static void lammps_file(IntPtr _0, string _1)
        {
            var arg0 = _0;
            var arg1 = _1;
            Internal.lammps_file_0(arg0, arg1);
        }

//        public static string lammps_command(HandleRef _0h, string _1)
//        {
//            var arg0 = _0h;
//            var arg1 = _1;
//            //var __ret = Internal.lammps_command_1(arg0, arg1);
//            IntPtr ptr= Internal.lammps_command_1(arg0, arg1);
//            return Marshal.PtrToStringAuto(ptr);
//            //return __ret;
//        }

        public static string lammps_command(IntPtr _0, string _1)
        {
            var arg0 = _0;
            var arg1 = _1;
            IntPtr ptr = Internal.lammps_command_0(arg0, arg1);
            return Marshal.PtrToStringAuto(ptr);
        }

        public static void lammps_free(HandleRef _0h)
        {
            var arg0 = _0h;
            Internal.lammps_free_0(arg0);
        }

        public static IntPtr lammps_extract_global(HandleRef _0h, string _1)
        {
            var arg0 = _0h;
            var arg1 = _1;
            var __ret = Internal.lammps_extract_global_0(arg0, arg1);
            if (__ret == IntPtr.Zero) return IntPtr.Zero;
            return __ret;
        }

        public static IntPtr lammps_extract_atom(HandleRef _0h, string _1)
        {
            var arg0 = _0h;
            var arg1 = _1;
            var __ret = Internal.lammps_extract_atom_0(arg0, arg1);
            if (__ret == IntPtr.Zero) return IntPtr.Zero;
            return __ret;
        }

        public static IntPtr lammps_extract_atom(IntPtr _0, string _1)
        {
            var arg0 = _0;
            var arg1 = _1;
            var __ret = Internal.lammps_extract_atom_0(arg0, arg1);
            if (__ret == IntPtr.Zero) return IntPtr.Zero;
            return __ret;
        }

        public static IntPtr lammps_extract_compute(HandleRef _0h, string _1, int _2, int _3)
        {
            var arg0 = _0h;
            var arg1 = _1;
            var __ret = Internal.lammps_extract_compute_0(arg0, arg1, _2, _3);
            if (__ret == IntPtr.Zero) return IntPtr.Zero;
            return __ret;
        }

        public static IntPtr lammps_extract_compute(IntPtr _0, string _1, int _2, int _3)
        {
            var arg0 = _0;
            var arg1 = _1;
            var __ret = Internal.lammps_extract_compute_0(arg0, arg1, _2, _3);
            if (__ret == IntPtr.Zero) return IntPtr.Zero;
            return __ret;
        }
        public static double lammps_extract_compute_double(HandleRef lmp, string computename)
        {
            //returns a compute that is a double
            var lmpcompute= lammps_extract_compute(lmp, computename,0,0);
            return (double)Marshal.PtrToStructure(lmpcompute, typeof(double));
        }

        public static double lammps_extract_compute_double(IntPtr lmp, string computename)
        {
            //returns a compute that is a double
            var lmpcompute= lammps_extract_compute(lmp, computename,0,0);
            return (double)Marshal.PtrToStructure(lmpcompute, typeof(double));
        }

        public static IntPtr lammps_extract_fix(HandleRef _0h, string _1, int _2, int _3, int _4, int _5)
        {
            var arg0 = _0h;
            var arg1 = _1;
            var __ret = Internal.lammps_extract_fix_0(arg0, arg1, _2, _3, _4, _5);
            if (__ret == IntPtr.Zero) return IntPtr.Zero;
            return __ret;
        }

        public static IntPtr lammps_extract_variable(HandleRef _0h, string _1, string _2)
        {
            var arg0 = _0h;
            var arg1 = _1;
            var arg2 = _2;
            var __ret = Internal.lammps_extract_variable_0(arg0, arg1, arg2);
            if (__ret == IntPtr.Zero) return IntPtr.Zero;
            return __ret;
        }

        public static int lammps_get_natoms(HandleRef _0h)
        {
            var arg0 = _0h;
            var __ret = Internal.lammps_get_natoms_0(arg0);
            return __ret;
        }
        public static IntPtr StringToByteArray(string s)
         {
             IntPtr p = new IntPtr();
             byte[] b = new byte[s.Length + 1];
             int i;
             for (i = 0; i < s.Length; i++)
                 b[i] = (byte)s.ToCharArray()[i];
             b[s.Length] = 0;
             p = Marshal.AllocCoTaskMem(s.Length + 1);
             Marshal.Copy(b, 0, p, s.Length + 1);
             return p;
         }
//        public static void lammps_gather_atoms(HandleRef _0h, string _1, int _2, int _3, void* _4)
//        {
//            var arg0 = _0;
//            var arg1 = _1;
//            var arg4 = _4;
//            Internal.lammps_gather_atoms_0(arg0, arg1, _2, _3, arg4);
//        }

//        public static void lammps_gather_atoms(HandleRef _0h, string _1, int _2, int _3, HandleRef _4)
//        {
//            var arg0 = _0;
//            var arg1 = _1;
//            var arg4 = _4.ToPointer();
//            Internal.lammps_gather_atoms_0(arg0, arg1, _2, _3, arg4);
//            _4 = new IntPtr(arg4);
//        }
        public static double[,] lammps_gather_atoms_dubs(HandleRef _0h, string _1, int count)//, // IntPtr arrayPtr)
        {
            var arg0 = _0h;
            var arg1 = _1;
            var dimension1 = Internal.lammps_get_natoms_0(arg0);
            int _3 = count; ///number of per atom values;

            double[,] ar = new double[dimension1, count];
            var arrayPtr = allocate_dubarray(dimension1, count);
            //var arg4 = new IntPtr();
            //int* unmanagedArray = (int*) UnmanagedType.SafeArray
            //int* arg4;
            Internal.lammps_gather_atoms_0(arg0, arg1, 1, count, arrayPtr);

           

            //int[] foo =new int[dimension2];
            //double[] foo =new double[count];
            double[] everyval = new double[count * dimension1];
            Marshal.Copy(arrayPtr, everyval, 0, count * dimension1);
            Marshal.FreeHGlobal(arrayPtr);
            //so what we have here is an "array" of values, so if we expect a 5x2 array from lammps what we really get back is a 10x1 array
            // with row 0,0, row 0,1 row 1,0 .....
            // we need to get this into an array we can use
            double[] row = new double[count];   
            for (int i = 0; i < dimension1; i++)
            {
                
                //Marshal.Copy(arrayPtr, row, i * count, count);
                for (int j = 0; j < count; j++)
                {
                    ar[i,j]=everyval[i*count+j];
                }
            }


            return ar;
        }

        public static double[,] lammps_gather_atoms_dubs(IntPtr _0, string _1, int count)//, // IntPtr arrayPtr)
        {
            var arg0 = _0;
            var arg1 = _1;
            var dimension1 = Internal.lammps_get_natoms_0(arg0);
            int _3 = count; ///number of per atom values;

            double[,] ar = new double[dimension1, count];
            var arrayPtr = allocate_dubarray(dimension1, count);
            //var arg4 = new IntPtr();
            //int* unmanagedArray = (int*) UnmanagedType.SafeArray
            //int* arg4;
            Internal.lammps_gather_atoms_0(arg0, arg1, 1, count, arrayPtr);

           

            //int[] foo =new int[dimension2];
            //double[] foo =new double[count];
            double[] everyval = new double[count * dimension1];
            Marshal.Copy(arrayPtr, everyval, 0, count * dimension1);
            Marshal.FreeHGlobal(arrayPtr);
            //so what we have here is an "array" of values, so if we expect a 5x2 array from lammps what we really get back is a 10x1 array
            // with row 0,0, row 0,1 row 1,0 .....
            // we need to get this into an array we can use
            double[] row = new double[count];   
            for (int i = 0; i < dimension1; i++)
            {
                
                //Marshal.Copy(arrayPtr, row, i * count, count);
                for (int j = 0; j < count; j++)
                {
                    ar[i,j]=everyval[i*count+j];
                }
            }


            return ar;
        }

        public static IntPtr allocate_dubarray(int dimension1, int dimension2)
        {
            //IntPtr foo = new IntPtr();
            //IntPtr arrayPtr = Marshal.AllocHGlobal(dimension1 * Marshal.SizeOf(typeof(IntPtr)));
            IntPtr arrayPtr = Marshal.AllocHGlobal(dimension1 *dimension2* Marshal.SizeOf(typeof(double)));
//            IntPtr[] dimension2Pointers = new IntPtr[dimension1];
//
//            for (int pos = 0; pos < dimension1; pos++)
//            {
//                dimension2Pointers[pos] = Marshal.AllocHGlobal(dimension2 * sizeof(double));
//            }
//
//            Marshal.Copy(dimension2Pointers, 0, arrayPtr, dimension1);
//            //Marshal.FreeHGlobal(arrayPtr);
            return arrayPtr;
        }
        public static void lammps_scatter_atoms(HandleRef _0h, string _1, int _2, int _3, HandleRef _4)
        {
            var arg0 = _0h;
            var arg1 = _1;
            var arg4 = _4;
            Internal.lammps_scatter_atoms_0(arg0, arg1, _2, _3, arg4);
        }


        public lammps(LAMMPSsettings settings)
        {
            //void* lamp;
            //lammps_open_no_mpi(0,null,&lamp);
            //lmp=new HandleRef(this,new IntPtr(lamp));
            //first entry must be empty
            string[] lmparg = new string[]{"","-screen","none"};
            //lmp=new HandleRef(this,lammps_open_no_mpi(3,lmparg));
            lmp=lammps_open_no_mpi(3,lmparg);
            initialize(settings);
        }
        public lammps(LAMMPSsettings settings, string[] lmparg)
        {
            //void* lamp;
            //lammps_open_no_mpi(0,null,&lamp);
            //lmp=new HandleRef(this,new IntPtr(lamp));
            //first entry must be empty
            
            //lmp=new HandleRef(this,lammps_open_no_mpi(3,lmparg));
            lmp=lammps_open_no_mpi(lmparg.Length,lmparg);
            initialize(settings);
        }
        public lammps(LAMMPSsettings settings, IntPtr comm)
        {
            //open with MPI
            //first entry must be empty
            string[] lmparg = new string[]{"","-screen","none"};
            //lmp=new HandleRef(this,lammps_open(0,null,comm));
            lmp=lammps_open(3,lmparg,comm);
            //lmp=new HandleRef(this,lammps_open(3,lmparg,comm));
            initialize(settings);
        }
        public lammps(LAMMPSsettings settings, IntPtr comm, string[] lmparg)
        {
            //open with MPI
            //first entry must be empty
            //string[] lmparg = new string[]{"","-screen","none"};
            //lmp=new HandleRef(this,lammps_open(0,null,comm));
            //lmp=new HandleRef(this,lammps_open(lmparg.Length,lmparg,comm));
            lmp=lammps_open(lmparg.Length,lmparg,comm);
            initialize(settings);
        }
        public void runCommand(string cmd)
        {
            lammps_command(lmp,cmd);
        }
        public double[,] getAtomPos()
        {
            double[,] atompos = lammps.lammps_gather_atoms_dubs(lmp, "x", 3);//, //out arrayPtr);
            return atompos;
        }
        public void minimize(double etol,double ftol, int maxiter, int maxeval, string min_style)
        {
            lammps.lammps_command(lmp, "min_style "+min_style);
            lammps.lammps_command(lmp, "minimize "+etol+" "+ftol+" "+maxiter+" "+ maxeval);
        }
        public void openFile(string file)
        {
            lammps.lammps_file(lmp,file);
        }

        private void initialize( LAMMPSsettings settings)
        {
            lammps_command(lmp,"units " + settings.units);

            lammps_command(lmp,"boundary " + settings.boundary);
            lammps_command(lmp,"atom_style " + settings.atom_style);
            lammps_command(lmp,"pair_style " + settings.pair_style); 


            //can choose not to have bonds, angles, dihedrals, or special bonds
            if (settings.bond_style != "")
            {
                var foo= lammps_command(lmp,"bond_style " + settings.bond_style);
            }
            if (settings.angle_style != "")
            {
                lammps_command(lmp,"angle_style " + settings.angle_style);
            }
            if (settings.dihedral_style != "")
            {
                lammps.lammps_command(lmp,"dihedral_style " + settings.dihedral_style);
            }
            if (settings.improper_style != "")
            {
                lammps.lammps_command(lmp,"improper_style " + settings.improper_style);
            }
            if (settings.special_bonds != "")
            {
                lammps.lammps_command(lmp,"special_bonds " + settings.special_bonds);
            }
        }
        ~lammps()
        {
            lammps_close(lmp);
        }
        public class LAMMPSsettings
        {
            public string units;
            public string boundary;
            public string atom_style;
            public string pair_style;
            public string bond_style;
            public string angle_style;
            public string dihedral_style;
            public string improper_style;
            public string special_bonds;

            public LAMMPSsettings()
            {
            //default settings for non-periodic UFF
                units = "real";
                boundary ="f f f";
                pair_style = "hybrid lj/cut 20";
                atom_style="full";
                bond_style = "hybrid harmonic";
                angle_style = "hybrid fourier harmonic";
                dihedral_style = "hybrid fourier harmonic";
                improper_style = "hybrid fourier harmonic";
                special_bonds = "lj 0.0 0.0 1.0";
            }
        }
    }
}
